# ClaudeCode プロンプトテンプレート集

このドキュメントは、ITSM-Sec Nexus プロジェクトで ClaudeCode を使用する際の標準化されたプロンプト集です。
往復開発ループの各フェーズで、これらのプロンプトをカスタマイズして使用してください。

---

## 📋 目次

1. [使い方](#使い方)
2. [フェーズ1: 初期レビュー](#フェーズ1-初期レビュー)
3. [フェーズ2: テスト強化](#フェーズ2-テスト強化)
4. [フェーズ3: セキュリティ検証](#フェーズ3-セキュリティ検証)
5. [フェーズ4: パフォーマンス最適化](#フェーズ4-パフォーマンス最適化)
6. [フェーズ5: ドキュメント整備](#フェーズ5-ドキュメント整備)
7. [フェーズ6: リファクタリング](#フェーズ6-リファクタリング)
8. [汎用プロンプト](#汎用プロンプト)

---

## 使い方

### 基本的な流れ

1. **Issue確認**: GitHub で自動作成された Issue を開く
2. **フェーズ選択**: Issue のチェックリストから次に実施するフェーズを選ぶ
3. **プロンプトカスタマイズ**: このドキュメントから該当フェーズのプロンプトをコピー
4. **変数置換**: `[PR番号]`, `[変更ファイル]` 等をIssueの情報で置き換え
5. **ClaudeCode実行**: ローカル環境で `claude-code` を起動し、プロンプトを入力
6. **PR作成**: ClaudeCode が提案した変更をレビュー後、PR作成

### 変数一覧

プロンプト内の以下の変数を実際の値で置き換えてください：

| 変数 | 説明 | 例 |
|------|------|-----|
| `[PR番号]` | 元のPR番号 | `#142` |
| `[Issue番号]` | 精緻化作業用Issue番号 | `#143` |
| `[変更ファイル]` | 変更されたファイルのリスト | `backend/routes/users.js` |
| `[機能名]` | 追加・修正された機能名 | ユーザー認証機能 |

---

## フェーズ1: 初期レビュー

### 目的
マージされたコードの全体的な品質を確認し、改善点を洗い出す。

### プロンプトテンプレート

```
# フェーズ1: 初期レビュー

Issue [Issue番号] のフェーズ1を実施します。
PR [PR番号] でマージされたコードをレビューし、以下の観点で改善点を洗い出してください。

## 対象ファイル
- [変更ファイルのリスト]

## レビュー観点

### 1. コード品質
- [ ] 可読性: 変数名・関数名は明確か
- [ ] 保守性: 将来の変更に強い設計か
- [ ] 設計: 責任分離（SRP）が適切か
- [ ] 重複: DRY原則が守られているか

### 2. エッジケース
- [ ] 境界値のテストが不足していないか
- [ ] null/undefined のハンドリングは適切か
- [ ] 空配列・空文字列の扱いは適切か
- [ ] 型チェックは十分か

### 3. エラーハンドリング
- [ ] try-catchで適切に捕捉されているか
- [ ] エラーメッセージは明確か
- [ ] エラーログは適切に出力されているか
- [ ] エラー時のロールバック処理は適切か

### 4. ログ出力
- [ ] 適切なログレベルか（error, warn, info, debug）
- [ ] 機密情報がログに含まれていないか
- [ ] デバッグ用のconsole.logが残っていないか

### 5. コメント・ドキュメント
- [ ] 複雑なロジックにコメントがあるか
- [ ] APIドキュメントは更新されているか（該当する場合）
- [ ] README.mdの更新が必要か

## 出力形式
以下の形式でレポートを作成してください：

1. **総評**: 全体的な品質評価（5段階）
2. **優れている点**: 良い実装・設計のポイント（3点まで）
3. **改善が必要な点**: 具体的な問題点と改善案（優先度順）
4. **次のアクション**: フェーズ2以降で対応すべき項目

## 制約事項
- README.mdの仕様は変更しない
- 既存のテストが通る状態を維持
- この段階では実装変更は不要（レポートのみ）
```

---

## フェーズ2: テスト強化

### 目的
テストカバレッジを80%以上に引き上げ、エッジケースのテストを追加する。

### プロンプトテンプレート

```
# フェーズ2: テスト強化

Issue [Issue番号] のフェーズ2を実施します。
[機能名] のテストカバレッジを80%以上に引き上げ、エッジケースのテストを追加してください。

## 対象ファイル
- [変更ファイルのリスト]

## 現在のカバレッジ
\`\`\`bash
npm run test:coverage
\`\`\`
上記コマンドで現在のカバレッジを確認してから作業を開始してください。

## テスト追加の観点

### 1. ユニットテスト（backend/__tests__/unit/）
- [ ] 正常系: 期待通りの入力で期待通りの出力を返すか
- [ ] 異常系: エラー入力で適切にエラーを返すか
- [ ] 境界値: 0, 空文字列, null, undefined の扱い
- [ ] エッジケース: 大量データ、特殊文字、最大値・最小値

### 2. 統合テスト（backend/__tests__/integration/）
- [ ] APIエンドポイントのテスト
- [ ] 認証・認可のテスト（JWT検証）
- [ ] データベース操作のテスト（CRUD）
- [ ] エラーレスポンスのテスト（400, 401, 404, 500）

### 3. E2Eテスト（該当する場合）
- [ ] ユーザーシナリオのテスト
- [ ] フロントエンド・バックエンド統合テスト

## テストコード記述規約
- **AAA パターン**: Arrange（準備）→ Act（実行）→ Assert（検証）
- **1テスト1検証**: expect() は原則1つまで
- **モック活用**: 外部依存（DB, API）はモック化
- **テストデータ**: 実データではなくダミーデータを使用

## カバレッジ目標
- **全体**: 80%以上
- **Statement**: 80%以上
- **Branch**: 75%以上
- **Function**: 80%以上
- **Line**: 80%以上

## 実行コマンド
\`\`\`bash
# ユニットテスト
npm run test:unit

# 統合テスト
npm run test:integration

# カバレッジ測定
npm run test:coverage
\`\`\`

## 制約事項
- 既存のテストは削除しない（修正は可）
- テストが失敗する状態でコミットしない
- テストデータに機密情報を含めない
```

---

## フェーズ3: セキュリティ検証

### 目的
NIST CSF 2.0 準拠の観点でセキュリティ脆弱性を検証し、対策を強化する。

### プロンプトテンプレート

```
# フェーズ3: セキュリティ検証

Issue [Issue番号] のフェーズ3を実施します。
[機能名] のセキュリティ脆弱性を検証し、NIST Cybersecurity Framework 2.0 に準拠した対策を実施してください。

## 対象ファイル
- [変更ファイルのリスト]

## セキュリティチェックリスト

### 1. 入力バリデーション（Identify）
- [ ] すべてのユーザー入力をバリデーションしているか
- [ ] 型チェック（文字列、数値、配列、オブジェクト）
- [ ] 長さ制限（最大文字数、配列サイズ）
- [ ] 正規表現検証（メールアドレス、URL等）
- [ ] ホワイトリスト方式を採用しているか

### 2. SQLインジェクション対策（Protect）
- [ ] プリペアドステートメント（パラメータ化クエリ）を使用しているか
- [ ] 生SQL文字列結合を行っていないか
- [ ] ORM（better-sqlite3）の機能を適切に使用しているか

### 3. XSS対策（Protect）
- [ ] 出力のエスケープ処理を行っているか
- [ ] フロントエンドで `textContent` を使用（`innerHTML` は禁止）
- [ ] ユーザー入力をそのまま画面表示していないか

### 4. 認証・認可（Protect）
- [ ] JWT トークンの検証を行っているか
- [ ] トークン有効期限を適切に設定しているか（1時間）
- [ ] Refresh Tokenの有効期限を適切に設定しているか（7日間）
- [ ] 認証不要エンドポイントが最小限か（`/api/v1/auth/*` のみ）
- [ ] ロールベース認証（admin, manager, analyst, viewer）が適切か

### 5. CSRF対策（Protect）
- [ ] CSRFトークン検証を行っているか
- [ ] SameSite Cookie属性を設定しているか

### 6. 機密情報の取り扱い（Protect）
- [ ] シークレット情報をハードコードしていないか
- [ ] 環境変数（`.env`）で管理しているか
- [ ] ログに機密情報（パスワード、トークン）を出力していないか
- [ ] GitHubにシークレットをコミットしていないか

### 7. レート制限（Detect）
- [ ] express-rate-limit を使用しているか
- [ ] APIエンドポイントごとに適切な制限値を設定しているか
- [ ] 429 Too Many Requests を返しているか

### 8. エラーメッセージ（Respond）
- [ ] エラーメッセージに内部情報を含めていないか
- [ ] スタックトレースを本番環境で出力していないか
- [ ] エラーログとユーザー向けメッセージを分けているか

## セキュリティスキャン実行
\`\`\`bash
# npm audit（依存関係の脆弱性）
npm audit --audit-level=moderate

# ESLint（セキュリティルール）
npm run lint

# Secretスキャン（機密情報の検出）
git grep -iE "password|api.?key|secret|token" -- ':!.github' ':!node_modules' ':!*.md'
\`\`\`

## NIST CSF 2.0 カテゴリマッピング
- **Identify (ID)**: 入力バリデーション、資産管理
- **Protect (PR)**: SQLインジェクション対策、XSS対策、認証・認可、CSRF対策
- **Detect (DE)**: レート制限、ログ監視
- **Respond (RS)**: エラーハンドリング、インシデント対応
- **Recover (RC)**: データバックアップ、復旧手順

## 制約事項
- セキュリティパッチ適用のためのパッケージ更新は許可
- 既存機能を破壊しない
- テストが通る状態を維持
```

---

## フェーズ4: パフォーマンス最適化

### 目的
N+1クエリ排除、不要なDB呼び出し削減、レスポンス時間短縮を実現する。

### プロンプトテンプレート

```
# フェーズ4: パフォーマンス最適化

Issue [Issue番号] のフェーズ4を実施します。
[機能名] のパフォーマンスを最適化し、レスポンス時間を短縮してください。

## 対象ファイル
- [変更ファイルのリスト]

## パフォーマンスチェックリスト

### 1. N+1クエリ問題（最重要）
- [ ] ループ内でDBクエリを実行していないか
- [ ] JOIN または `whereIn` で一括取得に変更できないか
- [ ] 関連データを事前にロードしているか

**悪い例（N+1）**:
\`\`\`javascript
const users = await db('users').select('*');
for (const user of users) {
  user.posts = await db('posts').where({ user_id: user.id });  // ❌ N回クエリ
}
\`\`\`

**良い例（JOIN）**:
\`\`\`javascript
const usersWithPosts = await db('users')
  .leftJoin('posts', 'users.id', 'posts.user_id')
  .select('users.*', 'posts.title as post_title');  // ✅ 1回のクエリ
\`\`\`

### 2. 不要なDB呼び出し削減
- [ ] 同じデータを複数回取得していないか
- [ ] 取得したデータを再利用できないか
- [ ] SELECT句で必要なカラムのみ取得しているか（`SELECT *` 禁止）

### 3. 大量データ処理の最適化
- [ ] ページネーション（limit, offset）を実装しているか
- [ ] 1回のクエリで取得する件数に上限を設けているか（推奨: 100件）
- [ ] カーソルベースページネーションを検討したか

### 4. キャッシュ導入
- [ ] 頻繁にアクセスされる静的データをキャッシュしているか
- [ ] キャッシュの有効期限を適切に設定しているか
- [ ] キャッシュのクリア条件を明確にしているか

### 5. インデックス確認
- [ ] WHERE句で使用するカラムにインデックスがあるか
- [ ] JOIN条件のカラムにインデックスがあるか
- [ ] マイグレーションファイルでインデックスを定義しているか

### 6. メモリリーク対策
- [ ] イベントリスナーを適切に削除しているか
- [ ] タイマー（setTimeout, setInterval）をクリアしているか
- [ ] ストリーム処理で close() を呼んでいるか

### 7. 非同期処理の最適化
- [ ] 並列実行可能な処理を `Promise.all()` で実行しているか
- [ ] 不要な `await` を削除しているか
- [ ] 長時間処理をバックグラウンド化しているか

## パフォーマンス測定

### レスポンス時間測定
\`\`\`javascript
const start = Date.now();
await targetFunction();
console.log(\`実行時間: \${Date.now() - start}ms\`);
\`\`\`

### クエリ実行回数確認
\`\`\`javascript
// better-sqlite3 でクエリをログ出力
db.on('query', (query) => {
  console.log('SQL:', query.sql);
});
\`\`\`

## パフォーマンス目標
- **API レスポンス時間**: 平均 < 200ms
- **DBクエリ回数**: 1リクエストあたり < 5回
- **メモリ使用量**: リクエスト処理後に増加しない（リークなし）

## 制約事項
- 機能を変更しない（内部実装の最適化のみ）
- テストが通る状態を維持
- 過度な最適化（可読性を犠牲にする）は避ける
```

---

## フェーズ5: ドキュメント整備

### 目的
コード内コメント、API仕様、README更新を行い、保守性を向上させる。

### プロンプトテンプレート

```
# フェーズ5: ドキュメント整備

Issue [Issue番号] のフェーズ5を実施します。
[機能名] のドキュメントを整備し、保守性を向上させてください。

## 対象ファイル
- [変更ファイルのリスト]

## ドキュメント整備チェックリスト

### 1. コード内コメント
- [ ] 複雑なロジックにコメントを追加
- [ ] アルゴリムの意図を説明
- [ ] TODO/FIXME/HACKコメントを整理
- [ ] 日本語コメントで記述（チームの言語に合わせる）

**コメント記述例**:
\`\`\`javascript
/**
 * ユーザー認証トークンを検証する
 * @param {string} token - JWTトークン
 * @returns {object} デコードされたユーザー情報
 * @throws {Error} トークンが無効な場合
 */
function verifyToken(token) {
  // トークンの署名を検証
  const decoded = jwt.verify(token, process.env.JWT_SECRET);

  // トークンの有効期限を確認
  if (decoded.exp < Date.now() / 1000) {
    throw new Error('Token expired');
  }

  return decoded;
}
\`\`\`

### 2. API仕様ドキュメント（該当する場合）
- [ ] 新しいエンドポイントを `Docs/API.md` に追記
- [ ] リクエスト形式（パラメータ、ボディ）を記載
- [ ] レスポンス形式（成功・エラー）を記載
- [ ] 認証要否を明記
- [ ] サンプルリクエスト・レスポンスを追加

**API仕様例**:
\`\`\`markdown
### POST /api/v1/auth/login

ユーザーログイン

**認証**: 不要

**リクエスト**:
\`\`\`json
{
  "username": "admin",
  "password": "password123"
}
\`\`\`

**レスポンス（成功）**:
\`\`\`json
{
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "...",
    "user": {
      "id": 1,
      "username": "admin",
      "role": "admin"
    }
  },
  "message": "ログイン成功"
}
\`\`\`

**レスポンス（エラー）**:
\`\`\`json
{
  "error": "INVALID_CREDENTIALS",
  "message": "ユーザー名またはパスワードが正しくありません"
}
\`\`\`
\`\`\`

### 3. README.md 更新（新機能の場合）
- [ ] 機能概要を追加
- [ ] 使用方法・サンプルコードを追加
- [ ] 設定項目（環境変数等）を追記
- [ ] スクリーンショット追加（該当する場合）

**注意**: README.mdの既存仕様は変更しない（追記のみ）

### 4. 使用例・サンプルコード
- [ ] 典型的な使用例を記載
- [ ] エラーハンドリングの例を記載
- [ ] コピー&ペーストで動くコードを提供

### 5. エラーメッセージの明確化
- [ ] エラーメッセージが具体的か
- [ ] ユーザーが次に取るべきアクションが明確か
- [ ] エラーコードとメッセージの対応表があるか

## ドキュメント記述規約
- **簡潔**: 必要最小限の情報を記載
- **具体的**: 抽象的な表現を避け、具体例を示す
- **更新日時**: ドキュメント末尾に最終更新日を記載
- **バージョン**: 重要な変更時はバージョン番号を更新

## 制約事項
- README.mdの仕様部分は変更しない（ドキュメント追記のみ）
- コードの動作を変更しない
- 過度なコメント（自明なコードへのコメント）は避ける
```

---

## フェーズ6: リファクタリング

### 目的
コードの可読性・保守性を向上させ、技術的負債を削減する。

### プロンプトテンプレート

```
# フェーズ6: リファクタリング

Issue [Issue番号] のフェーズ6を実施します。
[機能名] のリファクタリングを行い、コードの可読性・保守性を向上させてください。

## 対象ファイル
- [変更ファイルのリスト]

## リファクタリングチェックリスト

### 1. DRY原則（Don't Repeat Yourself）
- [ ] コードの重複を排除
- [ ] 共通処理を関数化・モジュール化
- [ ] 定数を一箇所で管理

**リファクタリング例（重複排除）**:
\`\`\`javascript
// ❌ Before（重複）
if (user.role === 'admin' || user.role === 'manager') { ... }
if (user.role === 'admin' || user.role === 'manager') { ... }

// ✅ After（関数化）
function isAuthorized(user) {
  return ['admin', 'manager'].includes(user.role);
}
if (isAuthorized(user)) { ... }
\`\`\`

### 2. 単一責任原則（SRP）
- [ ] 1つの関数・メソッドが1つの責任のみを持つか
- [ ] 長い関数（50行以上）を分割
- [ ] 複雑なロジックを小さな関数に分解

**リファクタリング例（関数分割）**:
\`\`\`javascript
// ❌ Before（多責任）
async function createUser(data) {
  // バリデーション
  if (!data.username) throw new Error('...');
  // パスワードハッシュ化
  const hash = await bcrypt.hash(data.password, 10);
  // DB保存
  await db('users').insert({ ...data, password: hash });
  // メール送信
  await sendEmail(data.email, '登録完了');
}

// ✅ After（単一責任）
async function validateUserData(data) { ... }
async function hashPassword(password) { ... }
async function saveUser(data) { ... }
async function sendWelcomeEmail(email) { ... }

async function createUser(data) {
  await validateUserData(data);
  const hashedPassword = await hashPassword(data.password);
  await saveUser({ ...data, password: hashedPassword });
  await sendWelcomeEmail(data.email);
}
\`\`\`

### 3. 変数・関数名の改善
- [ ] 意味のある名前を使用（`x`, `tmp`, `data` 等の曖昧な名前を避ける）
- [ ] 動詞 + 名詞の命名（例: `getUser`, `createPost`）
- [ ] boolean変数は `is`, `has`, `should` で始める

**リファクタリング例（命名改善）**:
\`\`\`javascript
// ❌ Before
const d = new Date();
const f = (x) => x * 2;
const chk = user.role === 'admin';

// ✅ After
const currentDate = new Date();
const doubleValue = (value) => value * 2;
const isAdmin = user.role === 'admin';
\`\`\`

### 4. マジックナンバーの定数化
- [ ] 数値リテラルを定数化
- [ ] 定数名で意味を明確化
- [ ] 定数を一箇所で管理（`constants.js` 等）

**リファクタリング例（定数化）**:
\`\`\`javascript
// ❌ Before
if (user.loginAttempts > 5) { ... }
setTimeout(callback, 3600000);

// ✅ After
const MAX_LOGIN_ATTEMPTS = 5;
const ONE_HOUR_MS = 60 * 60 * 1000;

if (user.loginAttempts > MAX_LOGIN_ATTEMPTS) { ... }
setTimeout(callback, ONE_HOUR_MS);
\`\`\`

### 5. 不要なコード削除
- [ ] 使用されていない変数・関数を削除
- [ ] コメントアウトされたコードを削除
- [ ] デバッグ用の `console.log()` を削除
- [ ] 未使用のimport文を削除

### 6. 早期リターン（Early Return）
- [ ] ネストを減らす
- [ ] ガード節を先に記述

**リファクタリング例（早期リターン）**:
\`\`\`javascript
// ❌ Before（深いネスト）
function processUser(user) {
  if (user) {
    if (user.isActive) {
      if (user.role === 'admin') {
        return '処理成功';
      } else {
        return '権限不足';
      }
    } else {
      return 'ユーザーが無効';
    }
  } else {
    return 'ユーザーが存在しない';
  }
}

// ✅ After（早期リターン）
function processUser(user) {
  if (!user) return 'ユーザーが存在しない';
  if (!user.isActive) return 'ユーザーが無効';
  if (user.role !== 'admin') return '権限不足';
  return '処理成功';
}
\`\`\`

### 7. 関数の引数を減らす
- [ ] 引数が4つ以上の場合、オブジェクトにまとめる
- [ ] オプション引数はデフォルト値を設定

**リファクタリング例（引数のオブジェクト化）**:
\`\`\`javascript
// ❌ Before
function createUser(name, email, age, role, department, isActive) { ... }

// ✅ After
function createUser({ name, email, age, role, department, isActive = true }) { ... }
\`\`\`

## リファクタリング実施手順
1. **テストの確認**: リファクタリング前にテストが通ることを確認
2. **小さな変更**: 一度に大きく変更せず、小さな変更を積み重ねる
3. **テストの実行**: 各変更後にテストを実行し、デグレがないか確認
4. **コミット**: 意味のある単位でコミット

## 制約事項
- 機能を変更しない（内部実装の改善のみ）
- テストが通る状態を維持
- 既存のAPIインターフェースを変更しない
- 過度なリファクタリングは避ける（可読性が優先）
```

---

## 汎用プロンプト

### 全フェーズ共通チェックリスト

```
# 往復開発ループ - 全フェーズ共通チェック

以下の項目は、すべてのフェーズで共通して確認してください。

## ✅ 実装前チェック
- [ ] CLAUDE.md の「往復開発ループモード」を確認
- [ ] Issue のチェックリストを確認
- [ ] 変更対象ファイルを確認
- [ ] 既存のテストが通ることを確認（`npm test`）

## ✅ 実装中チェック
- [ ] ESLint エラーが出ていないか（`npm run lint`）
- [ ] Prettier フォーマットが適用されているか（`npm run format`）
- [ ] 変更範囲が1フェーズの範囲内か（過剰な変更を避ける）
- [ ] 既存のテストが通る状態を維持しているか

## ✅ 実装後チェック
- [ ] すべてのテストが通るか（`npm test`）
- [ ] npm audit で脆弱性がないか（`npm audit`）
- [ ] README.mdの仕様に反する変更がないか
- [ ] コミットメッセージが Conventional Commits 形式か
- [ ] PR のタイトル・説明が明確か

## ✅ PR作成前チェック
- [ ] Issue のチェックリストを更新（完了した項目をチェック）
- [ ] 次のフェーズに進むか、この Issue をクローズするか判断
- [ ] PRのラベルを適切に設定（`refinement`, `claude-code`）
```

---

## 📌 プロンプト使用例

### 実際の使用例（フェーズ2: テスト強化）

```
# フェーズ2: テスト強化

Issue #143 のフェーズ2を実施します。
ユーザー認証機能のテストカバレッジを80%以上に引き上げ、エッジケースのテストを追加してください。

## 対象ファイル
- backend/routes/auth.js
- backend/middleware/auth.js
- backend/services/authService.js

## 現在のカバレッジ
\`\`\`bash
npm run test:coverage
\`\`\`
上記コマンドで現在のカバレッジを確認してから作業を開始してください。

（以下、テンプレートの内容をそのまま貼り付け）
```

---

**最終更新**: 2026-02-07
**作成者**: 開発チーム
**関連ドキュメント**: [CLAUDE.md](../CLAUDE.md), [copilot-instructions.md](../.github/copilot-instructions.md)
